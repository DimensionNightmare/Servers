module;
#include <sstream>
#include <format>
#include <ctime>
#include <cstdint>
#include "google/protobuf/message.h"
#include "google/protobuf/reflection.h"
#include "google/protobuf/descriptor.pb.h"
#include "pqxx/transaction"
#include "pqxx/result"

#include "StdMacro.h"
#include "Common/DbExtend.pb.h"
export module DbUtils;

import StrUtils;
import Logger;

using namespace std;
using namespace google::protobuf;

// statement
#define SSMBegin "("
#define SSMEnd ")"
#define SEnd ";"
#define SSplit ","
#define SSpace " "
#define SDefault "DEFAULT"
#define SCombo " AND "
#define SNOT "NOT"
#define SPrimaryKey "PRIMARY KEY"
#define SNULL "NULL"
#define SNOTNULL "NOT NULL"
#define SISNULL "IS NULL"
#define SNOTISNULL SNOT SSpace SISNULL
#define SWHERE " WHERE "
#define SSELECTALL "*"
#define SUPDATE "UPDATE"
#define SUPDATECOND "UPDATECOND"

enum class SqlOpType : uint8_t
{
	None,
	CreateTable,
	Insert,
	Query,
	Update,
	Delete,
};

const char* GetOpTypeBySqlOpType(SqlOpType eType)
{
	switch (eType)
	{
#define ONE(type, name) \
		case type: \
			return name;
		ONE(SqlOpType::CreateTable, "CREATE TABLE ");
		ONE(SqlOpType::Insert, "INSERT INTO ");
		ONE(SqlOpType::Query, "SELECT ");
		ONE(SqlOpType::Update, "UPDATE ");
		ONE(SqlOpType::Delete, "DELETE FROM ");
#undef ONE
		default:
			throw invalid_argument("Please Check SqlOpType");
			break;
	}

	return "";
}

const char* GetDbTypeByProtoType(FieldDescriptor::CppType pbType)
{
	// http://postgres.cn/docs/9.4/datatype-numeric.html#DATATYPE-INT
	switch (pbType)
	{
#define ONE(type, name) \
		case type:          \
			return #name;
		ONE(FieldDescriptor::CPPTYPE_DOUBLE, DOUBLE);
		ONE(FieldDescriptor::CPPTYPE_FLOAT, FLOAT);
		ONE(FieldDescriptor::CPPTYPE_INT32, INTEGER);
		ONE(FieldDescriptor::CPPTYPE_UINT32, INTEGER);
		ONE(FieldDescriptor::CPPTYPE_INT64, BIGINT);
		ONE(FieldDescriptor::CPPTYPE_UINT64, BIGINT);
		ONE(FieldDescriptor::CPPTYPE_STRING, TEXT);
		ONE(FieldDescriptor::CPPTYPE_ENUM, INTEGER);
		ONE(FieldDescriptor::CPPTYPE_BOOL, BOOL);
		ONE(FieldDescriptor::CPPTYPE_MESSAGE, BYTEA);
#undef ONE
		default:
			throw invalid_argument("Please Check CppType");
			break;
	}

	return "";
}

void InitFieldByProtoType(const FieldDescriptor* field, list<string>& out, list<string>& keys)
{
	const char* typeStr = GetDbTypeByProtoType(field->cpp_type());

	out.emplace_back(typeStr);

	// Type First Modify !!!
	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_STRING:
		{
			if (int lenLimit = field->options().GetExtension(ext_len_limit))
			{
				out.back().assign(format("VARCHAR({0})", lenLimit));
			}
			break;
		}
		case FieldDescriptor::CPPTYPE_UINT32:
		case FieldDescriptor::CPPTYPE_UINT64:
		{
			if (int lenLimit = field->options().GetExtension(ext_autogen))
			{
				out.emplace_back(format("GENERATED BY DEFAULT AS IDENTITY (START WITH {})", lenLimit));
			}

			out.emplace_back(format("CHECK ({0} > -1)", field->name()));
			break;
		}
		case FieldDescriptor::CPPTYPE_DOUBLE:
		{
			out.back().assign("double precision");
			break;
		}
		default:
			break;
	}

	if (field->is_repeated())
	{
		out.back() += "[]";
	}

	if (!field->has_optional_keyword())
	{
		out.emplace_back(SNOTNULL);
	}

	string defStr = field->options().GetExtension(ext_default);
	if (defStr.size())
	{
		out.emplace_back(format("{0} {1}", SDefault, defStr));
	}

	if (field->options().GetExtension(ext_primary_key))
	{
		keys.emplace_back(field->name());
	}

	if (field->options().GetExtension(ext_unique))
	{
		out.emplace_back("UNIQUE");
	}
}

/// @brief Get Message Field Value to String for *** INSERT *** Table
/// @param field
/// @param reflection
/// @param data
/// @param out
/// @return isNull
void InsertFieldByProtoType(const FieldDescriptor* field, const Reflection* reflection, Message& data, string& out)
{
	out.clear();

	bool isRepeat = field->is_repeated();

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_INT32:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out += to_string(reflection->GetRepeatedInt32(data, field, i)) + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = to_string(reflection->GetInt32(data, field));
			}
			break;
		case FieldDescriptor::CPPTYPE_UINT32:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out += to_string(reflection->GetRepeatedUInt32(data, field, i)) + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = to_string(reflection->GetUInt32(data, field));
			}

			break;
		case FieldDescriptor::CPPTYPE_INT64:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out += to_string(reflection->GetRepeatedInt64(data, field, i)) + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = to_string(reflection->GetInt64(data, field));
			}
			break;
		case FieldDescriptor::CPPTYPE_UINT64:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out += to_string(reflection->GetRepeatedUInt64(data, field, i)) + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = to_string(reflection->GetUInt64(data, field));
			}
			break;
		case FieldDescriptor::CPPTYPE_DOUBLE:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out += to_string(reflection->GetRepeatedDouble(data, field, i)) + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = to_string(reflection->GetDouble(data, field));
			}
			break;
		case FieldDescriptor::CPPTYPE_FLOAT:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out += to_string(reflection->GetRepeatedFloat(data, field, i)) + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = to_string(reflection->GetFloat(data, field));
			}
			break;
		case FieldDescriptor::CPPTYPE_STRING:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out = out + "'" + reflection->GetRepeatedString(data, field, i) + "'" + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = out + "'" + reflection->GetString(data, field) + "'";
			}
			break;
		case FieldDescriptor::CPPTYPE_BOOL:
			if (isRepeat)
			{
				for (int i = 0; i < reflection->FieldSize(data, field); i++)
				{
					out += to_string(reflection->GetRepeatedBool(data, field, i)) + ",";
				}
				out.pop_back();
				out = format("'{{ {} }}'", out);
			}
			else
			{
				out = to_string(reflection->GetBool(data, field));
			}
			break;
		case FieldDescriptor::CPPTYPE_MESSAGE:
			if (isRepeat)
			{
				throw invalid_argument("Please Regist InsertField::CppType");
			}
			else
			{
				const Message& msg = reflection->GetMessage(data, field);
				msg.SerializeToString(&out);
				BytesToHexString(out);
				out = format("E'\\\\x{}'", out);
			}
			break;
		default:
			throw invalid_argument("Please Regist InsertField::CppType");
			break;
	}

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_DOUBLE:
		{
			// if (field->options().GetExtension(ext_datetime))
			// {
			// 	out = format("TO_TIMESTAMP({})", out);
			// }
			break;
		}
		case FieldDescriptor::CPPTYPE_STRING: // len_limit
		{
			if (int len = field->options().GetExtension(ext_len_limit))
			{
				if (out.size() > len)
				{
					out = format("field {} lenth > {} limit !!!", field->name(), len);
					throw invalid_argument(out.c_str());
				}
			}
			break;
		}
		default:
			break;
	}
}

void SelectFieldNameByProtoType(const FieldDescriptor* field, string& out)
{
	// if (field->options().GetExtension(ext_datetime))
	// {
	// 	out = format("EXTRACT(EPOCH FROM {} at time zone 'UTC') as {}", out, out);
	// }
}

void SelectFieldByProtoType(const FieldDescriptor* field, const Reflection* reflection, Message& data, pqxx::row::reference value, bool isQueryAll)
{
	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_INT32:
			reflection->SetInt32(&data, field, value.as<int32_t>());
			break;
		case FieldDescriptor::CPPTYPE_UINT32:
			reflection->SetUInt32(&data, field, value.as<uint32_t>());
			break;
		case FieldDescriptor::CPPTYPE_INT64:
			reflection->SetInt64(&data, field, value.as<int64_t>());
			break;
		case FieldDescriptor::CPPTYPE_UINT64:
			reflection->SetUInt64(&data, field, value.as<uint64_t>());
			break;
		case FieldDescriptor::CPPTYPE_DOUBLE:
		{
			// if (isQueryAll && field->options().GetExtension(ext_datetime))
			// {
			// 	double timestamp = StringToTimestamp(value.as<string>());

			// 	reflection->SetDouble(&data, field, timestamp);
			// 	break;
			// }
			reflection->SetDouble(&data, field, value.as<double>());
			break;
		}
		case FieldDescriptor::CPPTYPE_FLOAT:
			reflection->SetFloat(&data, field, value.as<float>());
			break;
		case FieldDescriptor::CPPTYPE_STRING:
			reflection->SetString(&data, field, value.as<string>());
			break;
		case FieldDescriptor::CPPTYPE_BOOL:
			if (field->is_repeated())
			{
				pqxx::array_parser arr = value.as_array();
				pair<pqxx::array_parser::juncture, string> elem;
				int index = 0;

				do
				{
					elem = arr.get_next();
					if (elem.first == pqxx::array_parser::juncture::string_value)
					{
						reflection->AddBool(&data, field, false);
						reflection->SetRepeatedBool(&data, field, index, elem.second == "t");
						index++;
					}
				} while (elem.first != pqxx::array_parser::juncture::done);

			}
			else
			{
				reflection->SetBool(&data, field, value.as<bool>());
			}
			break;
		case FieldDescriptor::CPPTYPE_MESSAGE:
			{
				if(field->is_repeated())
				{
					throw invalid_argument("Please Regist SelectField::Type");
				}
				else
				{
					Message* msg = reflection->MutableMessage(&data, field);
					string msgData = value.as<string>();
					msgData = msgData.substr(2);
					HexStringToBytes(msgData);
					msg->ParseFromString(msgData);
				}
			}
			break;
		default:
			throw invalid_argument("Please Regist SelectField::Type");
			break;
	}
}

void SelectFieldCondByProtoType(const FieldDescriptor* field, const Reflection* reflection, Message& data, string& out)
{
	out.clear();

	if (field->has_optional_keyword() && !reflection->HasField(data, field))
	{
		out = SNULL;
		return;
	}

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_INT32:
			out = to_string(reflection->GetInt32(data, field));
			break;
		case FieldDescriptor::CPPTYPE_UINT32:
			out = to_string(reflection->GetUInt32(data, field));
			break;
		case FieldDescriptor::CPPTYPE_INT64:
			out = to_string(reflection->GetInt64(data, field));
			break;
		case FieldDescriptor::CPPTYPE_UINT64:
			out = to_string(reflection->GetUInt64(data, field));
			break;
		case FieldDescriptor::CPPTYPE_DOUBLE:
			out = to_string(reflection->GetDouble(data, field));
			break;
		case FieldDescriptor::CPPTYPE_FLOAT:
			out = to_string(reflection->GetFloat(data, field));
			break;
		case FieldDescriptor::CPPTYPE_STRING:
			out = format("'{}'", reflection->GetString(data, field));
			break;
		default:
			throw invalid_argument("Please Regist SelectFieldCond::Type");
			break;
	}

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_DOUBLE:
		{
			// if (field->options().GetExtension(ext_datetime))
			// {
			// 	out = format("TO_TIMESTAMP({})", out);
			// }
			break;
		}
		case FieldDescriptor::CPPTYPE_STRING: // len_limit
		{
			if (int len = field->options().GetExtension(ext_len_limit))
			{
				if (out.size() > len)
				{
					out = format("field {} lenth > {} limit !!!", field->name(), len);
					throw invalid_argument(out.c_str());
				}
			}
			break;
		}
		default:
			break;
	}
}

bool UpdateFieldByProtoType(const FieldDescriptor* field, const Reflection* reflection, Message& data, string& out)
{
	out.clear();

	if (field->has_optional_keyword() && !reflection->HasField(data, field))
	{
		out = SNULL;
		return true;
	}

	bool isRepeat = field->is_repeated();

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_INT32:
			out = to_string(reflection->GetInt32(data, field));
			break;
		case FieldDescriptor::CPPTYPE_UINT32:
			out = to_string(reflection->GetUInt32(data, field));
			break;
		case FieldDescriptor::CPPTYPE_INT64:
			out = to_string(reflection->GetInt64(data, field));
			break;
		case FieldDescriptor::CPPTYPE_UINT64:
			out = to_string(reflection->GetUInt64(data, field));
			break;
		case FieldDescriptor::CPPTYPE_DOUBLE:
			out = to_string(reflection->GetDouble(data, field));
			break;
		case FieldDescriptor::CPPTYPE_FLOAT:
			out = to_string(reflection->GetFloat(data, field));
			break;
		case FieldDescriptor::CPPTYPE_STRING:
			out = format("'{}'", reflection->GetString(data, field));
			break;
		case FieldDescriptor::CPPTYPE_MESSAGE:
			if (isRepeat)
			{
				throw invalid_argument("Please Regist UpdateField::CppType");
			}
			else
			{
				const Message& msg = reflection->GetMessage(data, field);
				msg.SerializeToString(&out);
				BytesToHexString(out);
				out = format("E'\\\\x{}'", out);
			}
			break;
		default:
			throw invalid_argument("Please Regist UpdateField::Type");
			break;
	}

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_DOUBLE:
		{
			// if (field->options().GetExtension(ext_datetime))
			// {
			// 	out = format("TO_TIMESTAMP({})", out);
			// }
			break;
		}
		case FieldDescriptor::CPPTYPE_STRING: // len_limit
		{
			if (int len = field->options().GetExtension(ext_len_limit))
			{
				if (out.size() > len)
				{
					out = format("field {} lenth > {} limit !!!", field->name(), len);
					throw invalid_argument(out.c_str());
				}
			}
			break;
		}
		default:
			break;
	}

	return true;
}

void UpdateFieldCondByProtoType(const FieldDescriptor* field, const Reflection* reflection, Message& data, string& out)
{
	out.clear();

	if (field->has_optional_keyword() && !reflection->HasField(data, field))
	{
		out = SNULL;
		return;
	}

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_INT32:
			out = to_string(reflection->GetInt32(data, field));
			break;
		case FieldDescriptor::CPPTYPE_UINT32:
			out = to_string(reflection->GetUInt32(data, field));
			break;
		case FieldDescriptor::CPPTYPE_INT64:
			out = to_string(reflection->GetInt64(data, field));
			break;
		case FieldDescriptor::CPPTYPE_UINT64:
			out = to_string(reflection->GetUInt64(data, field));
			break;
		case FieldDescriptor::CPPTYPE_DOUBLE:
			out = to_string(reflection->GetDouble(data, field));
			break;
		case FieldDescriptor::CPPTYPE_FLOAT:
			out = to_string(reflection->GetFloat(data, field));
			break;
		case FieldDescriptor::CPPTYPE_STRING:
			out = format("'{}'", reflection->GetString(data, field));
			break;
		default:
			throw invalid_argument("Please Regist UpdateFieldCond::Type");
			break;
	}

	switch (field->cpp_type())
	{
		case FieldDescriptor::CPPTYPE_DOUBLE:
		{
			// if (field->options().GetExtension(ext_datetime))
			// {
			// 	out = format("TO_TIMESTAMP({})", out);
			// }
			break;
		}
		case FieldDescriptor::CPPTYPE_STRING: // len_limit
		{
			if (int len = field->options().GetExtension(ext_len_limit))
			{
				if (out.size() > len)
				{
					out = format("field {} lenth > {} limit !!!", field->name(), len);
					throw invalid_argument(out.c_str());
				}
			}
			break;
		}
		default:
			break;
	}
}

export template <class TMessage = Message>
class DbSqlHelper
{
public:
	DbSqlHelper(pqxx::dbtransaction* work);
	~DbSqlHelper() = default;

	const string& GetName() { return TMessage::GetDescriptor()->name(); }

	const vector<TMessage>& Result() { return mResult; }

	uint32_t ResultCount() { return iQueryCount; }

	bool Commit();
	// create table
	DbSqlHelper<TMessage>& InitTable();
	// insert
	DbSqlHelper<TMessage>& Insert(TMessage& inObj);

	// query
	DbSqlHelper<TMessage>& Select(const char* name, ...);

	DbSqlHelper<TMessage>& SelectAll(bool foreach = false, bool quertCount = false);

	DbSqlHelper<TMessage>& SelectCond(TMessage& selObj, const char* name, const char* cond, const char* splicing, ...);

	DbSqlHelper<TMessage>& Update(TMessage& upObj, const char* name, ...);

	DbSqlHelper<TMessage>& UpdateCond(TMessage& upObj, const char* name, const char* cond, const char* splicing, ...);

	DbSqlHelper<TMessage>& DeleteCond(TMessage& outObj, const char* name, const char* cond, const char* splicing, ...);

	bool IsSuccess() { return bExecResult; }

	bool IsExist();

	DbSqlHelper<TMessage>& Limit(uint32_t limit);

private:
	DbSqlHelper();

	bool ChangeSqlType(SqlOpType type);

	void SetResult(int affectedRows);

	void BuildSqlStatement();

	void PaserQuery(pqxx::result& result);

private:
	vector<TMessage> mResult;

	SqlOpType eType;
	// create table, instert
	unordered_map<string, list<string>> mEles;

	pqxx::dbtransaction* pWork;

	string sSqlStatement;

	bool bExecResult;

	int iExecResultCount;

	uint32_t iLimitCount;

	uint32_t iQueryCount;
};

template <class TMessage>
DbSqlHelper<TMessage>::DbSqlHelper()
{
	mResult.clear();
	eType = SqlOpType::None;
	mEles.clear();
	pWork = nullptr;
	sSqlStatement.clear();
	bExecResult = false;
	iExecResultCount = 0;
	iLimitCount = 0;
	iQueryCount = 0;
}

template <class TMessage>
DbSqlHelper<TMessage>::DbSqlHelper(pqxx::dbtransaction* work) : DbSqlHelper()
{
	pWork = work;
}

template <class TMessage>
bool DbSqlHelper<TMessage>::IsExist()
{
	return pWork->query_value<bool>(format("SELECT EXISTS ( SELECT 1 FROM pg_catalog.pg_tables WHERE schemaname = 'public' AND tablename = '{}');", GetName()));
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::Limit(uint32_t limit)
{
	if (iQueryCount)
	{
		throw invalid_argument("Exist Limit Cant use count(*)");
	}

	iLimitCount = limit;

	return *this;
}

template <class TMessage>
bool DbSqlHelper<TMessage>::ChangeSqlType(SqlOpType type)
{
	if (eType != SqlOpType::None && eType != type)
	{
		throw invalid_argument("Not Commit to Change OpType");
		return false;
	}

	eType = type;
	bExecResult = false;
	iExecResultCount = 0;
	return true;
}

template <class TMessage>
void DbSqlHelper<TMessage>::SetResult(int affectedRows)
{
	switch (eType)
	{
		case SqlOpType::Update:
		case SqlOpType::Delete:
		case SqlOpType::Query:
		{
			bExecResult = affectedRows > 0;
			break;
		}
		case SqlOpType::Insert:
		case SqlOpType::CreateTable:
		{
			bExecResult = affectedRows == iExecResultCount;
			break;
		}
		default:
			throw invalid_argument("Please Imp SetResult Case!");
	}

	iExecResultCount = 0;
	eType = SqlOpType::None;
	mEles.clear();
}

template <class TMessage>
void DbSqlHelper<TMessage>::BuildSqlStatement()
{
	if (eType == SqlOpType::None)
	{
		return;
	}

	stringstream ss;

	string limit;

	if (iLimitCount)
	{
		limit = format(" limit {}", iLimitCount);
	}

	switch (eType)
	{
		case SqlOpType::CreateTable:
		{
			ss << GetOpTypeBySqlOpType(eType) << "\"" << GetName() << "\"";

			if (!mEles.size())
			{
				// data null
				return;
			}

			ss << SSMBegin;
			auto it = mEles.begin();
			auto itEnd = mEles.end();
			for (; it != itEnd; it++)
			{
				ss << it->first;
				for (string& props : it->second)
				{
					ss << SSpace << props;
				}

				if (next(it) != itEnd)
				{
					ss << SSplit;
				}
				else
				{
					ss << SSMEnd;
				}
			}
			ss << SEnd;

			iExecResultCount = 1;
			break;
		}
		case SqlOpType::Insert:
		{
			ss << GetOpTypeBySqlOpType(eType) << "\"" << GetName() << "\"";

			if (!mEles.size())
			{
				// key null
				return;
			}

			size_t dataLen = mEles.begin()->second.size();
			if (!dataLen)
			{
				// value null
				return;
			}

			ss << SSMBegin;
			auto it = mEles.begin();
			auto itEnd = mEles.end();
			vector<list<string>> mapping;
			for (; it != itEnd; it++)
			{
				ss << it->first;

				mapping.push_back(it->second);

				if (next(it) != itEnd)
				{
					ss << SSplit;
				}
				else
				{
					ss << SSMEnd;
				}
			}

			ss << "VALUES";

			size_t mappingSize = mapping.size() - 1;
			for (int lst = 0; lst < dataLen; lst++)
			{
				ss << SSMBegin;
				for (int pos = 0; pos < mapping.size(); pos++)
				{
					ss << mapping[pos].front();
					mapping[pos].pop_front();
					if (mappingSize != pos)
					{
						ss << SSplit;
					}
				}
				ss << SSMEnd;

				if (lst + 1 != dataLen)
				{
					ss << SSplit;
				}

				iExecResultCount = iExecResultCount + 1;
			}
			ss << SEnd;
			break;
		}
		case SqlOpType::Query:
		{
			string selectElems;
			auto it = mEles.begin();
			auto itEnd = mEles.end();
			for (; it != itEnd; it++)
			{
				if (!iQueryCount)
				{
					selectElems.append(it->first);
					if (next(it) != itEnd)
					{
						selectElems += SSplit;
					}
				}
				else
				{
					selectElems = "COUNT(*)";
					break;
				}
			}

			ss << GetOpTypeBySqlOpType(eType) << selectElems << " FROM " << "\"" << GetName() << "\"";

			bool hasCondition = false;

			for (it = mEles.begin(); it != itEnd; it++)
			{
				for (string& cond : it->second)
				{
					if (!hasCondition)
					{
						hasCondition = true;
						ss << SWHERE;
					}

					ss << cond;
				}
			}

			ss << limit;

			ss << SEnd;
			break;
		}
		case SqlOpType::Update:
		{
			auto& updates = mEles[SUPDATE];
			if (!updates.size())
			{
				throw invalid_argument("NOT SET UPDATE PROPERTY !");
			}

			string selectElems;
			auto it = updates.begin();
			auto itEnd = updates.end();
			for (; it != itEnd; it++)
			{
				selectElems.append(*it);

				if (next(it) != itEnd)
				{
					selectElems += SSplit;
				}
			}

			ss << GetOpTypeBySqlOpType(eType) << "\"" << GetName() << "\"" << " SET " << selectElems;

			auto& updateConds = mEles[SUPDATECOND];

			bool hasCondition = false;

			for (auto condIt = updateConds.begin(); condIt != updateConds.end(); condIt++)
			{
				if (!hasCondition)
				{
					hasCondition = true;
					ss << SWHERE;
				}

				ss << *condIt;
			}

			ss << limit;

			ss << SEnd;
			break;
		}
		case SqlOpType::Delete:
		{
			ss << GetOpTypeBySqlOpType(eType) << "\"" << GetName() << "\"";

			bool hasCondition = false;

			if (mEles.size())
			{
				auto it = mEles.begin();
				auto itEnd = mEles.end();

				for (it = mEles.begin(); it != itEnd; it++)
				{
					for (string& cond : it->second)
					{
						if (!hasCondition)
						{
							hasCondition = true;
							ss << SWHERE;
						}

						ss << cond;
					}
				}
			}

			ss << limit;

			ss << SEnd;
			break;
		}
		default:
			throw invalid_argument("Please Imp BuildSqlStatement Case!");
	}

	sSqlStatement = ss.str();
}

template <class TMessage>
bool DbSqlHelper<TMessage>::Commit()
{
	BuildSqlStatement();

	if (!pWork || sSqlStatement.empty())
	{
		return false;
	}

	DNPrint(0, LoggerLevel::Debug, "%s ", sSqlStatement.c_str());

	pqxx::result result = pWork->exec(sSqlStatement);

	if (eType == SqlOpType::Query)
	{
		if (!iQueryCount)
		{
			PaserQuery(result);
		}
		else
		{
			iQueryCount = result[0][0].as<uint32_t>();
		}
		
		iLimitCount = 0;
	}

	SetResult(result.affected_rows());

	return true;
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::InitTable()
{
	ChangeSqlType(SqlOpType::CreateTable);

	const Descriptor* descriptor = TMessage::GetDescriptor();

	list<string> primaryKey;

	for (int i = 0; i < descriptor->field_count(); i++)
	{
		const FieldDescriptor* field = descriptor->field(i);

		// should init table
		if (field->is_repeated() && field->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE)
		{
			throw runtime_error("Not imp!!!");
		}

		list<string> params;
		InitFieldByProtoType(field, params, primaryKey);

		// unregist type
		if (params.size() == 0)
		{
			continue;
		}

		mEles.emplace(make_pair(field->name(), params));
	}

	if (mEles.contains(SPrimaryKey))
	{
		throw invalid_argument("Not Allow Exist 'PRIMARY KEY' map key!");
	}

	if (primaryKey.size())
	{
		string temp = SSMBegin;
		for (auto it = primaryKey.begin(); it != primaryKey.end(); it++)
		{
			temp += *it;

			if (next(it) != primaryKey.end())
			{
				temp += SSplit;
			}
		}

		temp += SSMEnd;

		primaryKey.clear();
		primaryKey.emplace_back(temp);

		mEles.emplace(make_pair(SPrimaryKey, primaryKey));
	}

	return *this;
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::Insert(TMessage& inObj)
{
	ChangeSqlType(SqlOpType::Insert);

	const Descriptor* descriptor = TMessage::GetDescriptor();
	const Reflection* reflection = TMessage::GetReflection();

	string params;

	for (int i = 0; i < descriptor->field_count(); i++)
	{
		const FieldDescriptor* field = descriptor->field(i);

		if (field->is_repeated() && reflection->FieldSize(inObj, field))
		{

		}

		else if (!reflection->HasField(inObj, field))
		{
			continue;
		}

		InsertFieldByProtoType(field, reflection, inObj, params);

		if (!params.size())
		{
			params = SDefault;
		}
		mEles[field->name()].emplace_back(params);
	}

	return *this;
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::Select(const char* name, ...)
{
	ChangeSqlType(SqlOpType::Query);

	const Descriptor* descriptor = TMessage::GetDescriptor();
	const Reflection* reflection = TMessage::GetReflection();

	if (mEles.contains(SSELECTALL))
	{
		throw invalid_argument("exist other select statement!!");
	}

	if (const FieldDescriptor* field = descriptor->FindFieldByLowercaseName(name))
	{
		string name = field->name();
		SelectFieldNameByProtoType(field, name);
		mEles[name];
	}

	return *this;
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::SelectAll(bool foreach, bool quertCount)
{
	ChangeSqlType(SqlOpType::Query);

	// not default
	if (foreach)
	{
		const Descriptor* descriptor = TMessage::GetDescriptor();
		for (int i = 0; i < descriptor->field_count(); i++)
		{
			Select(descriptor->field(i)->lowercase_name().c_str());
		}
		return *this;
	}

	// not default
	iQueryCount = quertCount;

	mEles[SSELECTALL];

	if (mEles.size() > 1)
	{
		throw invalid_argument("exist other select statement!!");
	}

	return *this;
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::SelectCond(TMessage& selObj, const char* name, const char* cond, const char* splicing, ...)
{
	const Descriptor* descriptor = TMessage::GetDescriptor();
	const Reflection* reflection = TMessage::GetReflection();

	const FieldDescriptor* field = descriptor->FindFieldByLowercaseName(name);
	if (!field)
	{
		return *this;
	}

	string value;
	SelectFieldCondByProtoType(field, reflection, selObj, value);

	value = string() + splicing + name + cond + value;

	if (mEles.contains(SSELECTALL))
	{
		mEles[SSELECTALL].emplace_back(value);
	}
	else
	{
		mEles.begin()->second.emplace_back(value);
	}

	return *this;
}

template <class TMessage>
void DbSqlHelper<TMessage>::PaserQuery(pqxx::result& result)
{
	mResult.clear();

	vector<string> keys;
	for (int col = 0; col < result.columns(); ++col)
	{
		keys.push_back(result.column_name(col));
	}

	const Descriptor* descriptor = TMessage::GetDescriptor();
	const Reflection* reflection = TMessage::GetReflection();

	bool isQueryAll = mEles.contains(SSELECTALL);

	for (int row = 0; row < result.size(); row++)
	{
		TMessage gen;

		pqxx::row rowInfo = result[row];
		for (int col = 0; col < rowInfo.size(); col++)
		{
			if (rowInfo[col].is_null())
			{
				continue;
			}
			SelectFieldByProtoType(descriptor->FindFieldByLowercaseName(keys[col]), reflection, gen, rowInfo[col], isQueryAll);
		}
		mResult.push_back(gen);
	}
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::Update(TMessage& upObj, const char* name, ...)
{
	ChangeSqlType(SqlOpType::Update);

	const Descriptor* descriptor = TMessage::GetDescriptor();
	const Reflection* reflection = TMessage::GetReflection();

	const FieldDescriptor* field = descriptor->FindFieldByLowercaseName(name);
	if (!field)
	{
		return *this;
	}

	string value;
	UpdateFieldByProtoType(field, reflection, upObj, value);

	mEles[SUPDATE].emplace_back(format("{}={}", field->name(), value));

	return *this;
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::UpdateCond(TMessage& upObj, const char* name, const char* cond, const char* splicing, ...)
{
	ChangeSqlType(SqlOpType::Update);

	const Descriptor* descriptor = TMessage::GetDescriptor();
	const Reflection* reflection = TMessage::GetReflection();

	const FieldDescriptor* field = descriptor->FindFieldByLowercaseName(name);
	if (!field)
	{
		return *this;
	}

	string value;
	UpdateFieldCondByProtoType(field, reflection, upObj, value);
	value = string() + splicing + name + cond + value;

	mEles[SUPDATECOND].emplace_back(value);

	return *this;
}

template <class TMessage>
DbSqlHelper<TMessage>& DbSqlHelper<TMessage>::DeleteCond(TMessage& outObj, const char* name, const char* cond, const char* splicing, ...)
{
	ChangeSqlType(SqlOpType::Delete);

	const Descriptor* descriptor = TMessage::GetDescriptor();
	const Reflection* reflection = TMessage::GetReflection();

	const FieldDescriptor* field = descriptor->FindFieldByLowercaseName(name);
	if (!field)
	{
		return *this;
	}

	string value;

	UpdateFieldCondByProtoType(field, reflection, outObj, value);

	value = string() + splicing + name + cond + value;

	mEles[SUPDATECOND].emplace_back(value);

	return *this;
}
